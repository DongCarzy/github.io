(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{385:function(e,a,s){"use strict";s.r(a);var t=s(4),n=function(e){e.options.__data__block__={mermaid_382ee1c1:"graph LR\nsubgraph socket客户端\ns1(socket)\ns2(socket)\ns(...)\nsn(socket)\nend\nio(io多路复用)\ns1--\x3eio\ns2--\x3eio\ns--\x3eio\nsn--\x3eio\nio--\x3equeue(队列)\nqueue--\x3edispatch(文件事件分派器)\nsubgraph 事件处理器\ncmd1(命令请求处理器)\ncmd2(命令请求处理器)\ncmd3(命令请求处理器)\ncmd(...)\nend\ndispatch---\x3ecmd1\ndispatch---\x3ecmd2\ndispatch---\x3ecmd3\ndispatch---\x3ecmd\n",mermaid_64a56928:"graph TB \n\nbgsave--\x3e父进程\nA{是否有其他子进程在处理持久化}\n父进程--\x3eA\nA--是--\x3e直接返回,不出来\nA--否--\x3eB(fork子进程,阻塞)\nB--\x3e输出Backgroud_saving_started,并不在阻塞,响应其他命令\nB..->子进程\n子进程--\x3eC[[生成RDB文件,并替换原有的RDB文件]]\n子进程--信号通知父进程生成完毕--\x3e父进程\n",mermaid_64a567f4:"graph TB\n\nA((客户端))\nA--命令请求--\x3e服务器\n服务器--命令内容--\x3e现有AOF文件\n服务器--命令内容--\x3eAOF重写缓存\n",mermaid_64a5609e:"sequenceDiagram\ntitle: 主从复制\n\n从服务器 ->> 主服务器: SYNC请求\nnote over 主服务器: 创建快照\nloop\n主服务器 --\x3e> 主服务器: 缓冲快照生成期间的写命令\nend\n主服务器 ->> 从服务器: 同步快照\nnote over 从服务器: 载入,解析快照\nloop\n主服务器 --\x3e> 主服务器: 缓冲快照生成期间的写命令\nend\n主服务器 ->> 从服务器: 同步写缓冲\nnote over 从服务器: 载入缓冲\nloop\n主服务器->>从服务器: 增量同步\nend\n\n",mermaid_64a56060:"graph LR\nsubgraph 哨兵集群\nsentiner1\nsentiner2\nsentiner3\nend\nsubgraph 主从节点\nmaster--\x3eslave1\nmaster--\x3eslave2\nmaster--\x3eslave3\nend\nsentiner1-.1.->master\nsentiner1-.1.->slave1\nsentiner1-.1.->slave2\nsentiner1-.1.->slave3\n\nsentiner2-.2.->master\nsentiner2-.2.->slave1\nsentiner2-.2.->slave2\nsentiner2-.2.->slave3\n\nsentiner3-.3.->master\nsentiner3-.3.->slave1\nsentiner3-.3.->slave2\nsentiner3-.3.->slave3\n",mermaid_64a56028:"graph TB\nsubgraph 客户端\nclient1\nclient2\nend\nclient1 -.-> RedisClusterDrive\nclient2 -.-> RedisClusterDrive\nsubgraph cluster\nmaster1\nmaster2\nmaster3\nmaster1--\x3eslave1\nmaster2--\x3eslave2\nmaster3--\x3eslave13\nend\nRedisClusterDrive-.->master1\nRedisClusterDrive-.->master2\nRedisClusterDrive-.->master3\n"}},r=Object(t.a)({},(function(){var e=this,a=e._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"redis基础"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redis基础"}},[e._v("#")]),e._v(" Redis基础")]),e._v(" "),a("p",[e._v("Redis 是基于内存运行的高性能"),a("code",[e._v("K-V")]),e._v("数据库")]),e._v(" "),a("h2",{attrs:{id:"_1-redis为什么快"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-redis为什么快"}},[e._v("#")]),e._v(" 1. Redis为什么快")]),e._v(" "),a("ol",[a("li",[a("p",[e._v("基于内存")])]),e._v(" "),a("li",[a("p",[e._v("单线程,减少上下文的切换,同事保证原子性(redis6+ 可开启多线程)")]),e._v(" "),a("ol",[a("li",[e._v("开启方式,非必要不开启")]),e._v(" "),a("li",[e._v("命令执行依旧由主线程负责")]),e._v(" "),a("li",[e._v("多线程只是负责 "),a("code",[e._v("io")]),e._v(" 部分")])]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("io-threads-do-reads yes  #开启IO线程\nio-threads 6    # 设置IO线程数\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br")])])]),e._v(" "),a("li",[a("p",[e._v("IO多路复用(epoll, 非阻塞IO)")])]),e._v(" "),a("li",[a("p",[e._v("文件事件处理器(Reactor模式)")])])]),e._v(" "),a("Mermaid",{attrs:{id:"mermaid_382ee1c1",graph:e.$dataBlock.mermaid_382ee1c1}}),a("p",[a("code",[e._v("io多路复用")]),e._v("会同时监听多个套接字,当监听的套接字准备好执行"),a("code",[e._v("accept")]),e._v(","),a("code",[e._v("read")]),e._v(","),a("code",[e._v("write")]),e._v(","),a("code",[e._v("close")]),e._v("等操作时,就会产生相应的文件事件,"),a("code",[e._v("io多路复用")]),e._v("程序会将所有产生事件的套接字都压入一个队列,然后有序的每次仅一个套接字的方式传递给"),a("code",[e._v("文件事件分派器")]),e._v(","),a("code",[e._v("文件事件分派器")]),e._v("接收到套接字后会根据套接字产生的事件类型调用对应的时间处理器.")]),e._v(" "),a("h2",{attrs:{id:"_2-redis数据基础数据类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-redis数据基础数据类型"}},[e._v("#")]),e._v(" 2. Redis数据基础数据类型")]),e._v(" "),a("ul",[a("li",[e._v("string:  一个键对应一个值 (set k v), 内部维护的是一个动态字符串 SDS (Simple Dyamic String)")]),e._v(" "),a("li",[e._v("set: 是string字符串类型的无序集合,也不可重复(sadd key member)")]),e._v(" "),a("li",[e._v("zset: 与set类似,但是会关联一个double类型分数用来排序 (zadd key score member)")]),e._v(" "),a("li",[e._v("hash: 类似java的map,键值对集合,适合存储对象,可针对某一个属性进行修改")]),e._v(" "),a("li",[e._v("list: 列表,双向链表,可用来实现队列和栈的效果")])]),e._v(" "),a("h2",{attrs:{id:"_3-场景分析"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-场景分析"}},[e._v("#")]),e._v(" 3. 场景分析")]),e._v(" "),a("p",[e._v("根据不通的场景选择合适的数据类型")]),e._v(" "),a("h3",{attrs:{id:"_3-1-string应用场景"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-string应用场景"}},[e._v("#")]),e._v(" 3.1 string应用场景")]),e._v(" "),a("blockquote",[a("p",[e._v("当字符串长度小于1MB, 每次扩容加倍.  大于1MB是,每次扩容1MB")])]),e._v(" "),a("ul",[a("li",[e._v("常规的 key-value缓存")]),e._v(" "),a("li",[e._v("计数("),a("code",[e._v("incr")]),e._v(", "),a("code",[e._v("decr")]),e._v(", "),a("code",[e._v("incrby")]),e._v(", "),a("code",[e._v("decrby")]),e._v("), 阅读量,粉丝数等等")])]),e._v(" "),a("h3",{attrs:{id:"_3-2-set应用场景"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-set应用场景"}},[e._v("#")]),e._v(" 3.2 set应用场景")]),e._v(" "),a("blockquote",[a("p",[e._v("set 类似于 list, 但是会重拍顺序,并且保证内部元素是不重复的")])]),e._v(" "),a("ul",[a("li",[e._v("做集合的"),a("code",[e._v("交集")]),e._v(","),a("code",[e._v("并集")]),e._v(","),a("code",[e._v("差集")]),e._v("操作, 张三的好友列表放在 "),a("code",[e._v("key1")]),e._v(", 李四好友 "),a("code",[e._v("key2")]),e._v(", "),a("code",[e._v("sinterstore key3 key1 key2")]),e._v(", 则key3为两人的共同好友")]),e._v(" "),a("li",[e._v("抽奖功能,首页随机展示广告. "),a("code",[e._v("spop")]),e._v(", 将所有人的编号放在set中,通过 spop 随机取出一个元素")]),e._v(" "),a("li",[e._v("并集统计. 公共活动A参加的人放在集合 key1, 参加活动B的放在key2, 获取所有参加了活的人. "),a("code",[e._v("sumionstore key3 key1 key2")]),e._v(", key3则是参加了活动的所有人")])]),e._v(" "),a("h3",{attrs:{id:"_3-3-zset应用场景"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-zset应用场景"}},[e._v("#")]),e._v(" 3.3 zset应用场景")]),e._v(" "),a("blockquote",[a("p",[e._v("与set相比,多了一个 "),a("code",[e._v("score")]),e._v(" 权重属性,可按照 "),a("code",[e._v("score")]),e._v(" 排序")])]),e._v(" "),a("ul",[a("li",[e._v("排行榜: 考试成绩排名, 直播在线人数排行,礼物排行榜等等")])]),e._v(" "),a("h3",{attrs:{id:"_3-4-hash应用场景"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-4-hash应用场景"}},[e._v("#")]),e._v(" 3.4 hash应用场景")]),e._v(" "),a("blockquote",[a("p",[e._v("内部是一个 field <-> value 的映射")])]),e._v(" "),a("ul",[a("li",[e._v("存储人员或者商品的信息:  通过 "),a("code",[e._v("hset")]),e._v(" 修改某一个属性,而不用全部拿出来")]),e._v(" "),a("li",[e._v("购物车: key用户, field商品ID, value 数量")]),e._v(" "),a("li",[e._v("存储一些实时统计信息. 终端设备的电量,里程,存储量等各种统计信息,分别在不同的协议上报上来,可通过 "),a("code",[e._v("hset")]),e._v(" 修改对应的值,并通过 "),a("code",[e._v("hgetall")]),e._v(" 将信息全部拿出来")])]),e._v(" "),a("h3",{attrs:{id:"_3-5-list应用场景"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-5-list应用场景"}},[e._v("#")]),e._v(" 3.5 list应用场景")]),e._v(" "),a("blockquote",[a("p",[e._v("双向链表")])]),e._v(" "),a("ul",[a("li",[e._v("队列, A服务通过 "),a("code",[e._v("rpush")]),e._v("尾部压入数据, B服务通过 "),a("code",[e._v("lpop")]),e._v("从头部拿数据")]),e._v(" "),a("li",[e._v("下拉分页的效果:  "),a("code",[e._v("lrange")])])]),e._v(" "),a("h2",{attrs:{id:"_4-redis持久化方案"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-redis持久化方案"}},[e._v("#")]),e._v(" 4. Redis持久化方案")]),e._v(" "),a("p",[e._v("redis是内存数据库,宕机后数据会消失,因此需要将内存的数据持久化到磁盘,启动时恢复数据, redis有两种持久化方案,分别是 "),a("code",[e._v("RDB")]),e._v(" 和 "),a("code",[e._v("AOF")]),e._v(".")]),e._v(" "),a("h3",{attrs:{id:"_4-1-rdb-redis-database"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-rdb-redis-database"}},[e._v("#")]),e._v(" 4.1 RDB(Redis DataBase)")]),e._v(" "),a("p",[e._v("默认的存储方式, RDB是通过快照的方式完成的,它保存的是某一时刻的数据信息.")]),e._v(" "),a("div",{staticClass:"language-nginx line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-nginx"}},[a("code",[e._v('save "" '),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#关闭RDB功能")]),e._v("\n\nsave 3600 1 "),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#1小时内有一次变更则进行快照")]),e._v("\nsave 300 10 "),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#300秒内有10次变更则进行快照")]),e._v("\nsave 60 10000  "),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#1分钟内有1万次变更进行快照 ")]),e._v("\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br")])]),a("p",[e._v("可手动触发, 执行"),a("code",[e._v("save")]),e._v("阻塞备份或者 "),a("code",[e._v("bgsave")]),e._v("后台备份")]),e._v(" "),a("Mermaid",{attrs:{id:"mermaid_64a56928",graph:e.$dataBlock.mermaid_64a56928}}),a("h4",{attrs:{id:"优点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#优点"}},[e._v("#")]),e._v(" 优点")]),e._v(" "),a("ul",[a("li",[e._v("RDB是二进制的快照,占用空间小,方便传输(slave)")]),e._v(" "),a("li",[e._v("使用子进程处理持久化操作,提高redis性能")]),e._v(" "),a("li",[e._v("RDB格式回复快")])]),e._v(" "),a("h4",{attrs:{id:"缺点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#缺点"}},[e._v("#")]),e._v(" 缺点")]),e._v(" "),a("ul",[a("li",[e._v("不能保证数据完整性,丢失快照后的数据")]),e._v(" "),a("li",[e._v("主进程数据量大的时候, fork子进程时阻塞时间会比较久")])]),e._v(" "),a("h3",{attrs:{id:"_4-2-aof-append-only-file"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-aof-append-only-file"}},[e._v("#")]),e._v(" 4.2 AOF(append only file)")]),e._v(" "),a("p",[e._v("默认情况下不开启, 开启后redis会将所有的写入命令写入到aof文件中,记录一个过程,恢复时,按照顺序执行即可")]),e._v(" "),a("div",{staticClass:"language-nginx line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-nginx"}},[a("code",[e._v("appendonly yes "),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# 开启aof")]),e._v("\ndir . "),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#存储aof问价的位置")]),e._v("\nappendfilename  appendonly.aof  "),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# 文件名")]),e._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# aof重写")]),e._v("\nauto-aof-rewrite-percentage 100   "),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#当前文件大小超过上次AOF文件大小(启动时aof文件大小)百分比的时候重写")]),e._v("\nauto-aof-rewrite-min-size 64mb  "),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#文件小于64MB的时候,不需要重写")]),e._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# 手动通过命令 `bgrewriteaof` 进行重写")]),e._v("\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br")])]),a("p",[e._v("AOF重写后,大大缩小了文件的体积. 只包含了恢复当"),a("code",[e._v("前数据的所需的最小命令集合")]),e._v(".")]),e._v(" "),a("p",[e._v("收到重写信令 -> fork子进程携带主进程的数据副本->开启AOF重写缓存 -> 子进程完成重写 -> AOF重写缓存写入到新的AOF文件 -> 覆盖旧的AOF文件.")]),e._v(" "),a("Mermaid",{attrs:{id:"mermaid_64a567f4",graph:e.$dataBlock.mermaid_64a567f4}}),a("h4",{attrs:{id:"优点-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#优点-2"}},[e._v("#")]),e._v(" 优点")]),e._v(" "),a("ol",[a("li",[e._v("一般每隔1秒,后台线程执行一次同步操作,丢失的数据会比较少")]),e._v(" "),a("li",[e._v("可读性强, 例如误操作了 "),a("code",[e._v("flushall")]),e._v(", 再没有发生 "),a("code",[e._v("rewrite")]),e._v(",可将aof中最后的 "),a("code",[e._v("flushall")]),e._v("删除, 恢复数据")])]),e._v(" "),a("h4",{attrs:{id:"缺点-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#缺点-2"}},[e._v("#")]),e._v(" 缺点")]),e._v(" "),a("ol",[a("li",[e._v("文件大,恢复缓慢")]),e._v(" "),a("li",[e._v("redis性能会下降,会频繁的写AOF文件")])]),e._v(" "),a("h3",{attrs:{id:"_4-3-混合持久化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-3-混合持久化"}},[e._v("#")]),e._v(" 4.3 混合持久化")]),e._v(" "),a("div",{staticClass:"language-nginx line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-nginx"}},[a("code",[e._v("aof-use-db-preamble yes\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("文件的开头是 RBD格式的, 文件后面是 AOF 格式. 发生在 AOF 重写的时候.")]),e._v(" "),a("h2",{attrs:{id:"_5-事务"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-事务"}},[e._v("#")]),e._v(" 5. 事务")]),e._v(" "),a("ul",[a("li",[e._v("multi  开始事务, 命令会放入队列")]),e._v(" "),a("li",[e._v("exce 执行事务中的所有操作")]),e._v(" "),a("li",[e._v("discard 取消事务")]),e._v(" "),a("li",[e._v("watch 监视一个或者多个key, 执行前,key被修改则中断(discard)")]),e._v(" "),a("li",[e._v("unwatch: 取消watch所有的key的监视")])]),e._v(" "),a("p",[e._v("redis的事务是非原子性的,在一次执行ABC命令, 如果B发生类型错误,AC还是会执行的, 但是如果B发生语法错误,那么入队列的时候就发现了,ABC都不会执行. "),a("code",[e._v("sets a b")]),e._v(" 这种就是语法错误, "),a("code",[e._v("lpush a b")]),e._v(", a不是一个list结构时.")]),e._v(" "),a("p",[e._v("完整用法")]),e._v(" "),a("div",{staticClass:"language-nginx line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-nginx"}},[a("code",[e._v("watch balance  "),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# 监听余额")]),e._v("\n\nmulti  "),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#开启事务")]),e._v("\ndecrby blance 20  "),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#余额减20")]),e._v("\nincrby blance 40  "),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#余额加40")]),e._v("\nexce  "),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#提交事务")]),e._v("\nunwatch   "),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# 取消监听")]),e._v("\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br")])]),a("p",[e._v("如果在执行事务 "),a("code",[e._v("exce")]),e._v("前, balance 被另外的线程修改, 那么exec会返回 '(nil)' 执行失败,事务回滚,整个都不执行.")]),e._v(" "),a("h2",{attrs:{id:"_6-redis高可用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-redis高可用"}},[e._v("#")]),e._v(" 6. Redis高可用")]),e._v(" "),a("p",[e._v("主从模式, 哨兵模式, 集群模式")]),e._v(" "),a("h3",{attrs:{id:"_6-1-主从模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-1-主从模式"}},[e._v("#")]),e._v(" 6.1 主从模式")]),e._v(" "),a("blockquote",[a("p",[e._v("1住多从")])]),e._v(" "),a("ul",[a("li",[e._v("主机具有读写能力,从机读")])]),e._v(" "),a("Mermaid",{attrs:{id:"mermaid_64a5609e",graph:e.$dataBlock.mermaid_64a5609e}}),a("h3",{attrs:{id:"_6-2-哨兵模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-2-哨兵模式"}},[e._v("#")]),e._v(" 6.2 哨兵模式")]),e._v(" "),a("p",[e._v("主从模式下,当master宕机后,需要手动把从机切换到master, 而哨兵模式会自动选举,将其中一个slave作为新的master.")]),e._v(" "),a("p",[e._v("哨兵自己也可以进行集群,一般为基数个")]),e._v(" "),a("Mermaid",{attrs:{id:"mermaid_64a56060",graph:e.$dataBlock.mermaid_64a56060}}),a("h3",{attrs:{id:"_6-3-集群模式-cluster模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-3-集群模式-cluster模式"}},[e._v("#")]),e._v(" 6.3 集群模式(cluster模式)")]),e._v(" "),a("p",[e._v("哨兵模式下, 已经是高可用状态,但是他有一个严重的缺陷,就是所有机器的数据都是一样,极大的浪费内存. Redis 采用的是 "),a("code",[e._v("slot")]),e._v(" 插槽的方式,将不通的数据存储到不通的机器上,一共 "),a("code",[e._v("16383")]),e._v("个插槽.")]),e._v(" "),a("Mermaid",{attrs:{id:"mermaid_64a56028",graph:e.$dataBlock.mermaid_64a56028}})],1)}),[],!1,null,null,null);"function"==typeof n&&n(r);a.default=r.exports}}]);